<h2>Stream pipelines</h2>
<html>
 <head></head>
 <body>
  <p>By this topic, you have already learned different types of stream operations such as <code class="language-java">filter</code>, <code class="language-java">map</code> and <code class="language-java">reduce</code>. Now is the time to start using these operations together and get into more details on the real stream pipelines. In a sense, the idea of this topic is to consolidate your knowledge about streams and to guide you through more complex practice exercises.</p> 
  <h5 style="text-align: center;">More about operations in stream pipelines</h5> 
  <p>As a rule, production-ready streams contain multiple operations at once. It is possible to distinguish the following kinds of operations:</p> 
  <ul> 
   <li>filtering: using <code class="language-java">filter</code> or other methods to skip some of the elements like <code class="language-java">skip</code>, <code class="language-java">limit</code>, <code class="language-java">takeWhile</code> and so on;</li> 
   <li>mapping or modifying stream elements: for example, sorting or removing duplicates;</li> 
   <li>reducing or combining: <code class="language-java">reduce</code>, <code class="language-java">max</code>, <code class="language-java">min</code>, <code class="language-java">collect</code>, <code class="language-java">count</code> , <code class="language-java">findAny</code>, and so on.</li> 
  </ul> 
  <p>This is not a coincidence. These groups of operations compose a standard data pipeline in many information systems and streams are well suited to simulate them.</p> 
  <p>Let's consider an example of a stream with several operations. Suppose, there is a list of strings named <code class="language-java">words</code>. We would like to count the total number of words that start with <code class="language-java">"JA"</code> . The case is not important: <code class="language-java">"ja"</code>, <code class="language-java">"jA"</code>, and <code class="language-java">"Ja"</code> are suitable as well.</p> 
  <p>Here is our solution with the <code class="language-java">map</code>, <code class="language-java">filter</code> and <code class="language-java">count</code> operations.</p> 
  <pre><code class="language-java">List&lt;String&gt; words = List.of("JAR", "Java", "Kotlin", "JDK", "jakarta");

long numberOfWords = words.stream()
        .map(String::toUpperCase)         // convert all words to upper case
        .filter(s -&gt; s.startsWith("JA"))  // filter words using a prefix
        .count();                         // count the suitable words

System.out.println(numberOfWords); // 3</code></pre> 
  <p>Here is a picture that explains how this stream works:</p> 
  <p><img alt="" src="https://ucarecdn.com/cb1da64b-8a7e-4d8e-a931-d6ab12103358/"></p> 
  <p></p>
  <div class="alert alert-primary">
   If you use 
   <strong>IntelliJ IDEA</strong> as your primary IDE and would like to visualize stream pipelines, you can 
   <a target="_blank" href="https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html" rel="noopener noreferrer nofollow">read this article</a> and install 
   <a target="_blank" href="https://plugins.jetbrains.com/plugin/9696-java-stream-debugger" rel="noopener noreferrer nofollow">the Java Stream Debugger plugin</a>.
  </div>
  <p></p> 
  <p>It is obvious, that the result is 3 because the list contains only three suitable words (<code class="language-java">"JAR"</code>, <code class="language-java">"Java"</code>, <code class="language-java">"jakarta"</code>).</p> 
  <h5 style="text-align: center;">The order of execution</h5> 
  <p>But there is also one less obvious thing in the case of the previous example: the order of operations in this stream. It seems that the <code class="language-java">filter</code> operation is only called after the <code class="language-java">map</code> operation has converted all the elements to the upper case. But that is not always true. We can see it by ourselves by adding the <code class="language-java">peek</code> operation to print the intermediate elements of the stream.</p> 
  <p></p>
  <div class="alert alert-primary">
   <a target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-" rel="noopener noreferrer nofollow">As Javadoc says</a>, the 
   <code class="language-java">peek</code> method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline. Do not forget to remove it after debugging is completed.
  </div>
  <p></p> 
  <p>After adding the <code class="language-java">peek</code> operation before and after <code class="language-java">filter</code>, the stream will look like this:</p> 
  <pre><code class="language-java">long numberOfWords = words.stream()
        .map(String::toUpperCase)
        .peek(System.out::println)
        .filter(s -&gt; s.startsWith("JA"))
        .peek(System.out::println)
        .count();</code></pre> 
  <p>And here is its output:</p> 
  <pre><code class="language-java">JAR
JAR
JAVA
JAVA
KOTLIN
JDK
JAKARTA
JAKARTA</code></pre> 
  <p>This output actually means, that the <code class="language-java">filter</code> operation is applied to an element right after the element was mapped.</p> 
  <p></p>
  <div class="alert alert-warning">
   Do not try to predict the order of operations in a complex stream. Depending on the operations, the actual execution order may slightly differ from the expected one because of the internal stream optimization. The main point is that a stream will produce the result regardless of the execution order.
  </div>
  <p></p> 
  <h5 style="text-align: center;">Streams with custom classes</h5> 
  <p>In real situations, streams often process custom classes designed specifically for the program.</p> 
  <p>Let's assume that we have the <code class="language-java">Event</code> class that represents a public event, such as a conference, a film premiere, or a concert. It has two fields:</p> 
  <ul> 
   <li><code class="language-java">beginning</code> (<code class="language-java">LocalDate</code>) is a date when the event happens;</li> 
   <li><code class="language-java">name</code> (<code class="language-java">String</code>) that is the name of the event (for instance, <code class="language-java">"JavaOne â€“ 2017"</code>).</li> 
  </ul> 
  <p>Also, the class has getters and setters for each field with the corresponding names.</p> 
  <p>We also have a list of instances named <code class="language-java">events</code>.</p> 
  <p>Let's find all names of events that will occur from <strong>December 30</strong> to <strong>December 31, 2017</strong> (inclusively).</p> 
  <pre><code class="language-java">LocalDate after = LocalDate.of(2017, 12, 29);
LocalDate before = LocalDate.of(2018, 1, 1);
        
List&lt;String&gt; suitableEvents = events.stream()
        .filter(e -&gt; e.getBeginning().isAfter(after) &amp;&amp; e.getBeginning().isBefore(before))
        .map(Event::getName)
        .collect(Collectors.toList());</code></pre> 
  <p>The code above finds names of all suitable events and collects them to a new list of strings. The map methods allow us to make the transition from <code class="language-java">Event</code> objects to the <code class="language-java">String</code> objects.</p> 
  <h5 style="text-align: center;">Mapping and reducing functions</h5> 
  <p>Since functions are presented as objects of certain classes, we can <code class="language-java">map</code> and <code class="language-java">reduce</code> them similar to regular stream elements.</p> 
  <p>For example, we have a collection of integer predicates. Let's negate each predicate by using a map operator and then conjunct all predicates into one by using a reduce operator.</p> 
  <pre><code class="language-java">public static IntPredicate negateEachAndConjunctAll(Collection&lt;IntPredicate&gt; predicates) {
    return predicates.stream()
            .map(IntPredicate::negate)
            .reduce(n -&gt; true, IntPredicate::and);
}</code></pre> 
  <p>In this example, <code class="language-java">map</code> negates each predicate in a stream and then <code class="language-java">reduce</code> conjuncts all predicates into one. The <strong>initial value</strong> (seed) of reducing is a predicate that is always <code class="language-java">true</code>, because it's the neutral value for conjunction.</p> 
  <p>So, the input predicates <code class="language-java">P1(x), P2(x), ..., Pn(x)</code> will be reduced into one predicate <code class="language-java">Q(x) = not P1(x) and not P2(x) and ... and not Pn(x)</code>. Of course, this is not the most frequent way to apply streams, but it's worth knowing that such use is also possible.</p> 
  <h5 style="text-align: center;">Conclusion</h5> 
  <p>As you have seen, stream pipelines allow writing short and readable code to perform various evaluations. It is possible to combine many different operations in a single powerful stream. Keep in mind, that the order of performing the operation is determined by the stream itself. Do not try to influence it in any way.</p>
 </body>
</html>
